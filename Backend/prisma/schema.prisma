generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// --------------------------
// Departments
// --------------------------
model Department {
  id             Int               @id @default(autoincrement())
  name           String
  code           String            @unique
  headOfDepartment String?
  totalFaculty   Int?
  totalStudents  Int?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  // Relations
  faculties      Faculty[]
  classrooms     Classroom[]
  subjects       Subject[]
  timetableSlots TimetableSlot[]
  authorizedUsers AuthorizedUser[]
}

// --------------------------
// Faculty
// --------------------------
model Faculty {
  id                  Int        @id @default(autoincrement())
  name                String
  email               String     @unique
  phone               String?
  maxWeeklyLoad       Int
  averageLeavesPerMonth Float    @default(0)
  availableDays       String    // JSON string: ["MONDAY", "TUESDAY", ...]
  preferredSlots      String?   // JSON string: ["09:00-10:00", ...]
  departmentId        Int
  department          Department @relation(fields: [departmentId], references: [id])

  subjects            SubjectFaculty[]
  timetableSlots      TimetableSlot[]
}

// --------------------------
// Classroom
// --------------------------
model Classroom {
  id           Int       @id @default(autoincrement())
  name         String
  year         Int
  semester     Int
  departmentId Int
  createdAt    DateTime  @default(now())

  // Relations
  department   Department @relation(fields: [departmentId], references: [id])
  students     Student[]
  timetableSlots TimetableSlot[]
}

// --------------------------
// Students
// --------------------------
model Student {
  id                 Int       @id @default(autoincrement())
  name               String
  rollNumber         String    @unique
  email              String    @unique
  phone              String?
  classroomId        Int
  enrollmentYear     Int
  attendancePercentage Float?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  classroom Classroom @relation(fields: [classroomId], references: [id])
}

// --------------------------
// Subjects
// --------------------------
model Subject {
  id             Int       @id @default(autoincrement())
  code           String    @unique
  name           String
  departmentId   Int
  credits        Int?
  lecturesPerWeek Int?
  labsPerWeek    Int?      @default(0)
  classesPerWeek Int?
  classesPerDay  Int?
  type           String    // Lecture / Lab / Tutorial
  semester       Int
  durationPerClass Int?
  prerequisites  String?   // JSON string
  allowedRoomTypes String? // JSON string

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  department    Department @relation(fields: [departmentId], references: [id])
  // Optional classroom assignment handled via TimetableSlot; removed direct classroom relation to avoid
  // an incorrect self-relation.
  timetableSlots TimetableSlot[]
  facultyAssignments SubjectFaculty[]
}

// --------------------------
// Join table for Faculty â†” Subject
// --------------------------
model SubjectFaculty {
  facultyId Int
  subjectId Int

  faculty   Faculty @relation(fields: [facultyId], references: [id])
  subject   Subject @relation(fields: [subjectId], references: [id])

  @@id([facultyId, subjectId])
}

// --------------------------
// Timetable slots
// --------------------------
model TimetableSlot {
  id           Int       @id @default(autoincrement())
  dayOfWeek    String
  startTime    String
  endTime      String
  subjectId    Int
  timetableId   Int?
  facultyId    Int
  classroomId  Int
  semester     Int
  departmentId Int
  isFixed      Boolean   @default(false)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  subject    Subject    @relation(fields: [subjectId], references: [id])
  timetable  Timetable? @relation(fields: [timetableId], references: [id])
  faculty    Faculty    @relation(fields: [facultyId], references: [id])
  classroom  Classroom  @relation(fields: [classroomId], references: [id])
  department Department @relation(fields: [departmentId], references: [id])

  @@unique([dayOfWeek, startTime, classroomId])
}

// --------------------------
// Authorized Users
// --------------------------
model AuthorizedUser {
  id           Int       @id @default(autoincrement())
  name         String
  email        String    @unique
  password     String
  role         String    @default("FACULTY") // SUPERADMIN | TIMETABLE_ADMIN | HOD | FACULTY | VIEWER
  departmentId Int?
  phone        String?
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  department   Department? @relation(fields: [departmentId], references: [id])
  approvals    Approval[]
  generatedTimetables Timetable[]
}

// Enum values stored as strings in SQLite
// Role: SUPERADMIN | TIMETABLE_ADMIN | HOD | FACULTY | VIEWER

// --------------------------
// Timetables
// --------------------------
model Timetable {
  id           Int       @id @default(autoincrement())
  name         String
  generatedById Int
  status       String    @default("PENDING") // PENDING | APPROVED | REJECTED
  scoreJson    String?   // JSON string

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  generatedBy  AuthorizedUser @relation(fields: [generatedById], references: [id])
  slots        TimetableSlot[]
  approvals    Approval[]
}

// Enum values stored as strings in SQLite
// TimetableStatus: PENDING | APPROVED | REJECTED

// --------------------------
// Approval
// --------------------------
model Approval {
  id          Int       @id @default(autoincrement())
  timetableId Int
  approverId  Int
  status      String    // PENDING | APPROVED | REJECTED
  comments    String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  timetable   Timetable      @relation(fields: [timetableId], references: [id])
  approver    AuthorizedUser @relation(fields: [approverId], references: [id])
}

// Enum values stored as strings in SQLite
// ApprovalStatus: PENDING | APPROVED | REJECTED

